import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { AuthService } from '../../auth/services/auth.service';

export interface FactureItem {
  id: string;
  factureId: string;
  productId: string;
  productName: string;
  description?: string;
  quantity: number;
  unitPrice: number;
  total: number;
}

export interface Facture {
  id: string;
  number?: string;
  reference?: string;
  vendorId?: string;
  vendorName?: string;
  vendorEmail?: string;
  clientId?: string;
  clientName: string;
  clientEmail: string;
  clientAddress?: string;
  clientPhone?: string;
  date: Date | string;
  dueDate: Date | string;
  status: 'DRAFT' | 'PENDING' | 'PAID' | 'CANCELLED';
  total: number;
  subtotal?: number;
  tax?: number;
  discount?: number;
  notes?: string;
  items: FactureItem[];
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentMethod?: string;
  paymentStatus?: string;
  pdfUrl?: string;
}

@Injectable({
  providedIn: 'root'
})
export class FactureService {
  // URL de l'API pour les factures
  private apiUrl = 'http://localhost:8080/api/factures';

  constructor(
    private http: HttpClient,
    private authService: AuthService
  ) { }
  
  // Obtenir les headers d'authentification
  private getAuthHeaders(): HttpHeaders {
    const token = this.authService.getToken();
    return new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  // Récupérer toutes les factures depuis le backend Spring Boot
  getFactures(): Observable<Facture[]> {
    console.log('Récupération des factures depuis le backend Spring Boot:', this.apiUrl);
    return this.http.get<any>(this.apiUrl, { headers: this.getAuthHeaders() })
      .pipe(
        map(response => {
          console.log('Réponse du backend Spring Boot:', response);
          // Mapper les données du backend aux objets Facture
          if (Array.isArray(response)) {
            const factures = response.map(item => this.mapSpringResponseToFacture(item));
            console.log('Factures récupérées avec succès:', factures.length);
            return factures;
          } else {
            console.error('Format de réponse inattendu:', response);
            return []; // Retourner un tableau vide au lieu de lancer une erreur
          }
        }),
        catchError(error => {
          // En cas d'erreur, retourner un tableau vide au lieu de propager l'erreur
          console.error('Erreur lors de la récupération des factures:', error);
          return of([]);
        })
      );
  }
  
  // Récupérer toutes les factures (méthode utilisée par le dashboard)
  getAllFactures(): Observable<Facture[]> {
    return this.http.get<any>(this.apiUrl, { headers: this.getAuthHeaders() }).pipe(
      catchError(error => {
        console.error('Erreur lors de la récupération des factures:', error);
        // Retourner des données réelles uniquement
        return of([]);
      })
    );
  }
  
  // Récupérer les factures du vendeur connecté
  getVendorFactures(): Observable<Facture[]> {
    const currentUser = this.authService.getCurrentUser();
    if (!currentUser) {
      return of([]);
    }
    
    const vendorId = currentUser.id;
    const url = `${this.apiUrl}/vendor/${vendorId}`;
    
    return this.http.get<any>(url, { headers: this.getAuthHeaders() }).pipe(
      map(response => {
        if (!Array.isArray(response)) {
          return [];
        }
        
        return response.map(item => this.mapSpringResponseToFacture(item));
      }),
      catchError(error => {
        console.error('Erreur lors de la récupération des factures du vendeur:', error);
        return of([]);
      })
    );
  }
  
  // Récupérer une facture par son ID
  getFactureById(id: string): Observable<Facture> {
    console.log(`Récupération de la facture ${id} depuis le backend Spring Boot`);
    
    return this.http.get<any>(`${this.apiUrl}/${id}`, { headers: this.getAuthHeaders() })
      .pipe(
        map(response => this.mapSpringResponseToFacture(response)),
        catchError(error => {
          console.error(`Erreur lors de la récupération de la facture ${id}:`, error);
          return of(this.createEmptyFacture());
        })
      );
  }
  
  // Mapper une réponse du backend Spring Boot vers un objet Facture
  mapSpringResponseToFacture(item: any): Facture {
    if (!item) return this.createEmptyFacture();
    
    return {
      id: item.id || '',
      number: item.number || '',
      reference: item.reference || '',
      vendorId: item.vendorId || '',
      vendorName: item.vendorName || '',
      vendorEmail: item.vendorEmail || '',
      clientId: item.clientId || '',
      clientName: item.clientName || '',
      clientEmail: item.clientEmail || '',
      clientAddress: item.clientAddress || '',
      clientPhone: item.clientPhone || '',
      date: item.date ? new Date(item.date) : new Date(),
      dueDate: item.dueDate ? new Date(item.dueDate) : new Date(),
      status: this.mapStatusFromSpring(item.status),
      total: item.total || 0,
      subtotal: item.subtotal || 0,
      tax: item.tax || 0,
      discount: item.discount || 0,
      notes: item.notes || '',
      items: Array.isArray(item.items) ? this.mapLignesFacture(item.items) : [],
      createdAt: item.createdAt ? new Date(item.createdAt) : new Date(),
      updatedAt: item.updatedAt ? new Date(item.updatedAt) : new Date(),
      paymentMethod: item.paymentMethod || '',
      paymentStatus: item.paymentStatus || '',
      pdfUrl: item.pdfUrl || ''
    };
  }
  
  // Mapper les lignes de facture du backend Spring Boot
  mapLignesFacture(lignes: any[]): FactureItem[] {
    return lignes.map(ligne => ({
      id: ligne.id || '',
      factureId: ligne.factureId || '',
      productId: ligne.productId || '',
      productName: ligne.productName || '',
      description: ligne.description || '',
      quantity: ligne.quantity || 0,
      unitPrice: ligne.unitPrice || 0,
      total: ligne.total || 0
    }));
  }
  
  // Mapper le statut du backend Spring Boot au format attendu par l'application
  mapStatusFromSpring(status: string): 'DRAFT' | 'PENDING' | 'PAID' | 'CANCELLED' {
    if (!status) return 'DRAFT';
    
    switch (status.toUpperCase()) {
      case 'BROUILLON':
        return 'DRAFT';
      case 'EN ATTENTE':
        return 'PENDING';
      case 'PAYEE':
      case 'PAYÉ':
      case 'PAYÉE':
        return 'PAID';
      case 'ANNULEE':
      case 'ANNULÉ':
      case 'ANNULÉE':
        return 'CANCELLED';
      default:
        return 'PENDING';
    }
  }
  
  // Générer des données factices pour le tableau de bord
  generateMockFactures(): Facture[] {
    console.log('Génération de factures factices pour le tableau de bord');
    const factures: Facture[] = [];
    
    // Générer 20 factures factices
    for (let i = 0; i < 20; i++) {
      const date = new Date();
      date.setDate(date.getDate() - Math.floor(Math.random() * 180)); // Date aléatoire dans les 180 derniers jours
      
      const dueDate = new Date(date);
      dueDate.setDate(date.getDate() + 30); // Échéance à 30 jours
      
      const statuses: ('DRAFT' | 'PENDING' | 'PAID' | 'CANCELLED')[] = ['DRAFT', 'PENDING', 'PAID', 'CANCELLED'];
      // Augmenter la probabilité d'avoir des factures payées pour de meilleures statistiques
      const statusIndex = Math.random() < 0.6 ? 2 : Math.floor(Math.random() * statuses.length);
      const status = statuses[statusIndex];
      
      const items: FactureItem[] = [];
      const itemCount = Math.floor(Math.random() * 5) + 1; // 1 à 5 articles
      
      let total = 0;
      
      // Liste de produits prédéfinis pour avoir des données plus cohérentes
      const products = [
        { id: 'prod-1', name: 'Ordinateur portable', price: 1200, category: 'Informatique' },
        { id: 'prod-2', name: 'Smartphone', price: 800, category: 'Téléphonie' },
        { id: 'prod-3', name: 'Tablette', price: 500, category: 'Informatique' },
        { id: 'prod-4', name: 'Casque audio', price: 150, category: 'Audio' },
        { id: 'prod-5', name: 'Imprimante', price: 300, category: 'Informatique' },
        { id: 'prod-6', name: 'Télévision', price: 900, category: 'Électroménager' },
        { id: 'prod-7', name: 'Enceinte Bluetooth', price: 120, category: 'Audio' },
        { id: 'prod-8', name: 'Montre connectée', price: 250, category: 'Accessoires' }
      ];
      
      // Sélectionner des produits aléatoires
      const selectedProductIndices = [];
      for (let j = 0; j < itemCount; j++) {
        let productIndex;
        do {
          productIndex = Math.floor(Math.random() * products.length);
        } while (selectedProductIndices.includes(productIndex));
        
        selectedProductIndices.push(productIndex);
        
        const product = products[productIndex];
        const quantity = Math.floor(Math.random() * 5) + 1; // 1 à 5 unités
        const unitPrice = product.price;
        const itemTotal = quantity * unitPrice;
        
        items.push({
          id: `item-${i}-${j}`,
          factureId: `mock-${i}`,
          productId: product.id,
          productName: product.name,
          description: `${product.category} - ${product.name}`,
          quantity,
          unitPrice,
          total: itemTotal
        });
        
        total += itemTotal;
      }
      
      // Générer des clients réalistes
      const clients = [
        { id: 'client-1', name: 'Entreprise ABC', email: 'contact@abc.com' },
        { id: 'client-2', name: 'Société XYZ', email: 'info@xyz.com' },
        { id: 'client-3', name: 'Jean Dupont', email: 'jean.dupont@example.com' },
        { id: 'client-4', name: 'Marie Martin', email: 'marie.martin@example.com' },
        { id: 'client-5', name: 'Tech Solutions', email: 'contact@techsolutions.com' }
      ];
      
      const clientIndex = i % clients.length;
      const client = clients[clientIndex];
      
      // Générer un numéro de facture réaliste
      const year = date.getFullYear();
      const month = date.getMonth() + 1;
      const formattedMonth = month < 10 ? `0${month}` : `${month}`;
      const invoiceNumber = `F-${year}${formattedMonth}-${i.toString().padStart(3, '0')}`;
      
      factures.push({
        id: `mock-${i}`,
        number: invoiceNumber,
        vendorId: '1',
        vendorName: 'Votre Entreprise',
        vendorEmail: 'contact@votreentreprise.com',
        clientId: client.id,
        clientName: client.name,
        clientEmail: client.email,
        date,
        dueDate,
        status,
        total,
        discount: Math.random() > 0.7 ? Math.floor(total * 0.1) : 0, // 30% de chance d'avoir une remise de 10%
        notes: Math.random() > 0.5 ? 'Notes sur la facture' : '',
        items,
        createdAt: date,
        updatedAt: date
      });
    }
    
    // Trier les factures par date (les plus récentes d'abord)
    factures.sort((a, b) => {
      const dateA = a.date instanceof Date ? a.date.getTime() : new Date(a.date).getTime();
      const dateB = b.date instanceof Date ? b.date.getTime() : new Date(b.date).getTime();
      return dateB - dateA;
    });
    
    return factures;
  }

  // Créer une facture vide pour éviter les erreurs d'affichage
  createEmptyFacture(): Facture {
    const now = new Date();
    const dueDate = new Date();
    dueDate.setDate(now.getDate() + 30); // Échéance à 30 jours
    
    return {
      id: '',
      clientName: '',
      clientEmail: '',
      date: now,
      dueDate: dueDate,
      status: 'DRAFT',
      total: 0,
      items: []
    };
  }
  
  // Créer une nouvelle facture
  createFacture(facture: Facture): Observable<Facture> {
    console.log('Création d\'une nouvelle facture:', facture);
    
    // Envoyer uniquement au backend Spring Boot sans créer de données simulées
    return this.http.post<any>(this.apiUrl, facture, { headers: this.getAuthHeaders() }).pipe(
      map(response => {
        console.log('Réponse du backend Spring Boot pour la création de facture:', response);
        return this.mapSpringResponseToFacture(response);
      }),
      catchError(error => {
        console.error('Erreur lors de la création de la facture:', error);
        throw error; // Renvoyer l'erreur au lieu de créer une facture simulée
      })
    );
  }
  
  // Mettre à jour le statut d'une facture
  updateFactureStatus(id: string, status: 'DRAFT' | 'PENDING' | 'PAID' | 'CANCELLED'): Observable<Facture> {
    console.log(`Mise à jour du statut de la facture ${id} à ${status}`);
    
    // Convertir le statut au format attendu par le backend
    const springStatus = this.mapStatusToSpring(status);
    
    const url = `${this.apiUrl}/${id}/status`;
    return this.http.patch<any>(url, { status: springStatus }, { headers: this.getAuthHeaders() }).pipe(
      map(response => {
        console.log('Réponse du backend Spring Boot pour la mise à jour du statut:', response);
        return this.mapSpringResponseToFacture(response);
      }),
      catchError(error => {
        console.error(`Erreur lors de la mise à jour du statut de la facture ${id}:`, error);
        throw error;
      })
    );
  }
  
  // Mapper le statut de l'application au format attendu par le backend Spring Boot
  mapStatusToSpring(status: 'DRAFT' | 'PENDING' | 'PAID' | 'CANCELLED'): string {
    switch (status) {
      case 'DRAFT':
        return 'BROUILLON';
      case 'PENDING':
        return 'EN_ATTENTE';
      case 'PAID':
        return 'PAYEE';
      case 'CANCELLED':
        return 'ANNULEE';
      default:
        return 'EN_ATTENTE';
    }
  }
  
  // Générer un PDF pour une facture
  generatePdf(id: string): Observable<Blob> {
    console.log(`Génération du PDF pour la facture ${id}`);
    
    const url = `${this.apiUrl}/${id}/pdf`;
    
    return this.http.get(url, {
      headers: this.getAuthHeaders(),
      responseType: 'blob'
    }).pipe(
      catchError(error => {
        console.error(`Erreur lors de la génération du PDF pour la facture ${id}:`, error);
        throw error;
      })
    );
  }
  
  // Générer le contenu HTML pour un PDF de facture
  private generateHtmlForPdf(facture: Facture): string {
    // Calculer les totaux
    const subtotal = facture.subtotal || facture.items.reduce((sum, item) => sum + item.total, 0);
    const discount = facture.discount || 0;
    const tax = facture.tax || 0;
    const total = subtotal + tax - discount;
    
    // Formater les dates
    const formatDate = (date: Date | string) => {
      const d = date instanceof Date ? date : new Date(date);
      return d.toLocaleDateString('fr-FR');
    };
    
    const formattedDate = formatDate(facture.date);
    const formattedDueDate = formatDate(facture.dueDate);
    
    // Générer le tableau des articles
    let itemsHtml = '';
    facture.items.forEach(item => {
      itemsHtml += `
        <tr>
          <td>${item.productName}</td>
          <td>${item.description || ''}</td>
          <td style="text-align: right;">${item.quantity}</td>
          <td style="text-align: right;">${item.unitPrice.toFixed(2)} €</td>
          <td style="text-align: right;">${item.total.toFixed(2)} €</td>
        </tr>
      `;
    });
    
    // Créer le HTML complet de la facture
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8" />
        <title>Facture ${facture.number}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
          .invoice-box { max-width: 800px; margin: auto; padding: 30px; border: 1px solid #eee; box-shadow: 0 0 10px rgba(0, 0, 0, 0.15); }
          .invoice-box table { width: 100%; line-height: inherit; text-align: left; }
          .invoice-box table td { padding: 5px; vertical-align: top; }
          .invoice-box table tr.top table td { padding-bottom: 20px; }
          .invoice-box table tr.heading td { background: #eee; border-bottom: 1px solid #ddd; font-weight: bold; }
          .invoice-box table tr.item td { border-bottom: 1px solid #eee; }
          .invoice-box table tr.total td:nth-child(5) { border-top: 2px solid #eee; font-weight: bold; }
          .status { display: inline-block; padding: 5px 10px; border-radius: 5px; font-weight: bold; }
          .status-paid { background-color: #d4edda; color: #155724; }
          .status-pending { background-color: #fff3cd; color: #856404; }
          .status-cancelled { background-color: #f8d7da; color: #721c24; }
          .status-draft { background-color: #e2e3e5; color: #383d41; }
        </style>
      </head>
      <body>
        <div class="invoice-box">
          <table cellpadding="0" cellspacing="0">
            <tr class="top">
              <td colspan="5">
                <table>
                  <tr>
                    <td>
                      <h1>FACTURE</h1>
                      <strong>N° ${facture.number}</strong><br />
                      Date: ${formattedDate}<br />
                      Échéance: ${formattedDueDate}
                    </td>
                    <td style="text-align: right;">
                      <div class="status status-${facture.status.toLowerCase()}">
                        ${this.getStatusLabel(facture.status)}
                      </div>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
            
            <tr class="information">
              <td colspan="5">
                <table>
                  <tr>
                    <td>
                      <strong>Émetteur:</strong><br />
                      ${facture.vendorName || ''}<br />
                      ${facture.vendorEmail || ''}
                    </td>
                    <td style="text-align: right;">
                      <strong>Client:</strong><br />
                      ${facture.clientName}<br />
                      ${facture.clientEmail}
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
            
            <tr class="heading">
              <td>Produit</td>
              <td>Description</td>
              <td style="text-align: right;">Quantité</td>
              <td style="text-align: right;">Prix unitaire</td>
              <td style="text-align: right;">Total</td>
            </tr>
            
            ${itemsHtml}
            
            <tr>
              <td colspan="3"></td>
              <td style="text-align: right;"><strong>Sous-total:</strong></td>
              <td style="text-align: right;">${subtotal.toFixed(2)} €</td>
            </tr>
            
            ${tax > 0 ? `
            <tr>
              <td colspan="3"></td>
              <td style="text-align: right;"><strong>TVA:</strong></td>
              <td style="text-align: right;">${tax.toFixed(2)} €</td>
            </tr>` : ''}
            
            ${discount > 0 ? `
            <tr>
              <td colspan="3"></td>
              <td style="text-align: right;"><strong>Remise:</strong></td>
              <td style="text-align: right;">${discount.toFixed(2)} €</td>
            </tr>` : ''}
            
            <tr class="total">
              <td colspan="3"></td>
              <td style="text-align: right;"><strong>Total:</strong></td>
              <td style="text-align: right;">${total.toFixed(2)} €</td>
            </tr>
          </table>
          
          ${facture.notes ? `
          <div style="margin-top: 30px;">
            <strong>Notes:</strong>
            <p>${facture.notes}</p>
          </div>` : ''}
          
          <div style="margin-top: 30px; text-align: center; color: #777;">
            <p>Ce document est une facture générée automatiquement.</p>
          </div>
        </div>
      </body>
      </html>
    `;
  }
  
  // Obtenir le libellé du statut d'une facture
  private getStatusLabel(status: string): string {
    switch (status) {
      case 'PAID':
        return 'Payée';
      case 'PENDING':
        return 'En attente';
      case 'CANCELLED':
        return 'Annulée';
      case 'DRAFT':
        return 'Brouillon';
      default:
        return status;
    }
  }
  
  // Envoyer une facture par email
  sendFactureByEmail(id: string, email: string, subject?: string, message?: string): Observable<any> {
    console.log(`Envoi de la facture ${id} par email à ${email}`);
    
    const url = `${this.apiUrl}/${id}/envoyer`;
    const body = {
      email,
      subject: subject || 'Votre facture',
      message: message || 'Veuillez trouver ci-joint votre facture.'
    };
    
    return this.http.post<any>(url, body, { headers: this.getAuthHeaders() }).pipe(
      catchError(error => {
        console.error(`Erreur lors de l'envoi de la facture ${id} par email:`, error);
        throw error;
      })
    );
  }
  
  // Calculer le sous-total d'une facture
  calculateSubtotal(items: FactureItem[]): number {
    return items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
  }
  
  // Calculer le montant de la TVA
  calculateTaxAmount(subtotal: number, taxRate: number): number {
    return subtotal * (taxRate / 100);
  }
  
  // Calculer le total d'une facture
  calculateTotal(subtotal: number, taxAmount: number, discount: number = 0): number {
    return subtotal + taxAmount - discount;
  }
}
